<!DOCTYPE html>
<html lang="en">

<head>

    <!-- Global site tag (gtag.js) - Google Analytics -->
    <script async src="https://www.googletagmanager.com/gtag/js?id=UA-161822888-1"></script>
    <script>
        window.dataLayer = window.dataLayer || [];

        function gtag() {
            dataLayer.push(arguments);
        }
        gtag('js', new Date());
        gtag('config', 'UA-161822888-1');

    </script>

    <title>Oculus example</title>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <meta name="viewport" content="width=device-width, user-scalable=no, minimum-scale=1.0, maximum-scale=1.0">
    <style>
        body {
            margin: 0;
        }

    </style>
</head>

<body>
    <script src="//cdn.rawgit.com/mrdoob/three.js/master/build/three.min.js"></script>
    <!--<script src="VRController.js"></script>-->
    <script type="module">
        import * as THREE from '//cdn.rawgit.com/mrdoob/three.js/master/build/three.module.js';
        import { OrbitControls } from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/controls/OrbitControls.js';
		import { VRButton } from '//cdn.rawgit.com/mrdoob/three.js/master/examples/jsm/webxr/VRButton.js';
            

// Global variables
var camera, scene, renderer;
var geometry, material, mesh;
var collectionBrainCoordinates = new THREE.Geometry();
var controller1, controller2;
var controls;
var POIs = new Array();

        
var points;     
var selectionDirection = 0.0;

var cursor = new THREE.Vector3();

var nodes = new Array();
var bboxnodes = new Array();
    
var object1;
var object2;
        
var realcont1;
var realcont1connected = false;
var realcont2;
var realcont2connected = false;
        
var colorBuffer;
var placePOIButtonPressed = false;
        
var user = new THREE.Group();     

        
// Start functions        
init();
animate();   
        
// Option 1 (legacy?): pass the name variable to download that specific file from S3        
var filename = getQueryVariable('name', null);

// Option 2: get a base64 encoded json from the header...
var json_base64 = getQueryVariable('jsonb64', null);

// Option 3: get a base64 encoded pointcloud
var base64_str = getQueryVariable('base64', null);
        
if(filename){
    var url = "https://pointcloudvisualization.s3.eu-central-1.amazonaws.com/"+filename;

    if(url.endsWith("xyzi")){
        startLoadingData(url, "XYZI");
    }
    else{
        startLoadingData(url, "XYZRGB");
    }
}
else if(base64_str){
    var tempPoints = getPointsFromBase64String(base64_str, "XYZI");
    scene.add(tempPoints);
}
else if(json_base64){
    var decodedData = JSON.parse(atob(json_base64));            
    // Parse the JSON 
    if("points" in decodedData){
        // Currently multiple point clouds are not supported
        var pointToLoad = decodedData["points"][0];

        if(pointToLoad['source'] == 'url'){
            startLoadingData(pointToLoad['url'], pointToLoad["type"]);
        }
        else if(pointToLoad['source'] == 'base64'){
            var tempPoints = getPointsFromBase64String(pointToLoad["base64"], pointToLoad["type"]);
            scene.add(tempPoints);
        }
    }
    if("bboxes" in decodedData){
        var boxesToLoad = decodedData["bboxes"][0];
        if(boxesToLoad['source'] == 'url'){
            startLoadingBoxes(boxesToLoad['url']);
        }
    }
}
else{
    // For now: always load something just because it's cool... 
    var url = "https://pointcloudvisualization.s3.eu-central-1.amazonaws.com/cars3.npy";
    startLoadingData(url, "XYZI");
}        

/*
Example JSON: 
{
    "points": [
        {
            "source": "url",
            "url": https://pointcloudvisualization.s3.eu-central-1.amazonaws.com/e2652aab-4ace-4a09-86f4-374b23cb677b.xyzi",
            "type": "RGBI",
        },
        {
            "source": "base64",
            "base64": "Pttmyz4gkd8/BK5QPwvLhz3XReU9+osQPpbxoD9Yolw+tjy9PwRGQD8KfRU9YXGEP1TPlD9AG2M/M/e+Pv8/8j7JjBE/TdywPsiFpz9x8sg=",
            "type": "RGBI"
        }
    ]
    "bboxes": [
        {
            "source": "url",
            "url": "https://pointcloudvisualization.s3.eu-central-1.amazonaws.com/test1.bbox"
        },
        {
            "source": "base64",
            "base64": "SDFLksf459fjssfhwDHFFhfs+fsfh=",
        }
    ]
}
*/
        

        
function get_bbox_vehicle(posx, posy, posz, sizex, sizey, sizez, rotationy){
    var geometry = new THREE.BoxGeometry( sizex, sizey, sizez);

    var material = new THREE.MeshPhongMaterial({
      color: 0x00ff00,
      opacity: 0.5,
      transparent: true,
    });

    // parent
    parent = new THREE.Object3D();
    parent.rotation.z = 0;
    parent.rotation.y = rotationy;
    parent.position.x = -posx;
    parent.position.y = -posy;
    parent.position.z = -posz;

    // mesh
    var mesh1 = new THREE.Mesh( geometry, material );
    
    parent.add( mesh1 );
    return parent;
}
        
        
function startLoadingBoxes(url){
    var httpRequest = new XMLHttpRequest();
    httpRequest.onreadystatechange = function() {
        if (httpRequest.readyState === 4){
            // everything is good, the response is received
            if ((httpRequest.status == 200) || (httpRequest.status == 0)){
                var buffer = httpRequest.response;
                 var dataview = new DataView(buffer);
                
                var points_per_row = 7;
                
                // Note: divide by 4 because of float32 has 4 bytes
                var ints = dataViewToFloat32Array(dataview, buffer.byteLength / 4)
                
                for(var row=0; row < ints.length; row=row+points_per_row) {
                    
                    bboxnodes[row/points_per_row] = new Array();
                    for(var p=0; p < points_per_row; p++){ //xyz...
                        bboxnodes[row/points_per_row][p] = ints[row+p] 
                    }
                }
                
            console.log("Loaded num bboxes " + bboxnodes.length)

            var particles = bboxnodes.length;
            var geometry = new THREE.BufferGeometry();
            var positions = [];
            var colors = [];
            var color = new THREE.Color();

            for ( var i = 0; i < particles; i ++ ) {
                var temp = get_bbox_vehicle(bboxnodes[i][0], bboxnodes[i][1], bboxnodes[i][2], bboxnodes[i][3], bboxnodes[i][4], bboxnodes[i][5], bboxnodes[i][6]);
                scene.add(temp);
        }}}}

    
    // Send the request
    console.log("Getting url for boxes", url)
    httpRequest.open("GET", url, true);
    httpRequest.responseType = "arraybuffer";

    httpRequest.send();
}
    
        
function getQueryVariable(variable, elsevalue) {
    var query = window.location.search.substring(1);
    var vars = query.split('&');
    for (var i = 0; i < vars.length; i++) {
        var pair = vars[i].split('=');
        if (decodeURIComponent(pair[0]) == variable) {
            return decodeURIComponent(pair[1]);
        }
    }
    return elsevalue;
}

function _base64ToArrayBuffer(base64) {
    var binary_string = window.atob(base64);
    var len = binary_string.length;
    var bytes = new Uint8Array(len);
    for (var i = 0; i < len; i++) {
        bytes[i] = binary_string.charCodeAt(i);
    }
    return bytes.buffer;
}

function dataViewToFloat32Array(dataview, lengthArray){
     var ints = new Float32Array(lengthArray);
     for (var i = 0; i < ints.length; i++) {
         ints[i] = dataview.getFloat32(i * 4);
     }
    return ints;
}
        
function getPointsFromBase64String(buffer, pointType){
    buffer = _base64ToArrayBuffer(buffer);
    var dataview = new DataView(buffer);
    
    // Note: divide by 4 because of float32 has 4 bytes
    var ints = dataViewToFloat32Array(dataview, buffer.byteLength / 4)

    var tempNodes = new Array();
    var points_per_row = get_points_per_row(pointType);
    for(var row=0; row < ints.length; row=row+points_per_row) {
        tempNodes[row/points_per_row] = new Array();
        for(var p=0; p < points_per_row; p++){ //xyz...
            tempNodes[row/points_per_row][p] = ints[row+p] 
        }
    }

    console.log("Loaded num points " + tempNodes.length)

    var particles = tempNodes.length;
    var geometry = new THREE.BufferGeometry();
    var positions = [];
    var colors = [];
    var color = new THREE.Color();

    for ( var i = 0; i < particles; i ++ ) {
        // positions
        var x = tempNodes[i][0];
        var y = tempNodes[i][1];
        var z = tempNodes[i][2];
        positions.push( x, y, z );
        
        if(pointType == "XYZI"){
            color.setHSL(tempNodes[i][3], 1.0, 0.5);
            colors.push( color.r, color.g, color.b );
        }
        else if(pointType == "XYZRGB"){
            colors.push( tempNodes[i][3], nodes[i][4], nodes[i][5] );
        }
    }
    
    geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
    colorBuffer = new THREE.Float32BufferAttribute( colors, 3 );

    geometry.setAttribute( 'color', colorBuffer );
    geometry.computeBoundingSphere();
    
    var material = new THREE.PointsMaterial( { size: 0.04, vertexColors: THREE.VertexColors } );
    var tempPoints = new THREE.Points( geometry, material );
    
    return tempPoints;
}        

function get_points_per_row(pointType){
    if(pointType == "XYZ"){
        return 3;
    }
    else if(pointType == "XYZI"){
        return 4;
    }
    else if(pointType == "XYZRGB"){
        return 6;
    }
}

function startLoadingData(url, pointType)
{
    var httpRequest = new XMLHttpRequest();
    httpRequest.onreadystatechange = function() {
        if (httpRequest.readyState === 4){
            // everything is good, the response is received
            if ((httpRequest.status == 200) || (httpRequest.status == 0)){
                var buffer = httpRequest.response;
                 var dataview = new DataView(buffer);
                
                
                // Note: divide by 4 because of float32 has 4 bytes
                var ints = dataViewToFloat32Array(dataview, buffer.byteLength / 4)
                
                var points_per_row = get_points_per_row(pointType);
                for(var row=0; row < ints.length; row=row+points_per_row) {
                    nodes[row/points_per_row] = new Array();
                    for(var p=0; p < points_per_row; p++){ //xyz...
                        nodes[row/points_per_row][p] = ints[row+p] 
                    }
                }
                
            console.log("Loaded num points " + nodes.length + " of point type " + pointType + " with ppr: " + points_per_row)

            var particles = nodes.length;
            var geometry = new THREE.BufferGeometry();
            var positions = [];
            var colors = [];
            var color = new THREE.Color();

            for ( var i = 0; i < particles; i ++ ) {
                // positions
                var x = nodes[i][0];
                var y = nodes[i][1];
                var z = nodes[i][2];
                positions.push( x, y, z );
                
                if(pointType == "XYZI"){
                    color.setHSL(nodes[i][3], 1.0, 0.5);
                    colors.push( color.r, color.g, color.b );
                }
                else if(pointType == "XYZRGB"){
                    colors.push( nodes[i][3], nodes[i][4], nodes[i][5] );
                }
            }
            geometry.setAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
            colorBuffer = new THREE.Float32BufferAttribute( colors, 3 );
            
            geometry.setAttribute( 'color', colorBuffer );
            geometry.computeBoundingSphere();
            //
            var material = new THREE.PointsMaterial( { size: 0.04, vertexColors: THREE.VertexColors } );
            points = new THREE.Points( geometry, material );
            //points.frustumCulled = false;
            scene.add( points );
            

        }}}

    
    // Send the request
    httpRequest.open("GET", url, true);
    httpRequest.responseType = "arraybuffer";

    httpRequest.send();
}
      
 function onSelectStart(){
    selectionDirection = 1.0 * points.scale.x;
     
 }
 function onSelectEnd(){
    selectionDirection = 0.0;
 }
        
function onSelectStartRight(){
    selectionDirection = -1.0 * points.scale.x;
     
 }
 function onSelectEndRight(){
    selectionDirection = 0.0;
 }
        
        
function getHand(){
    var radius = 0.08;
    var geometry =  new THREE.ConeGeometry( radius, 4*radius, 8 );
    var object=new THREE.Mesh( geometry, new THREE.MeshLambertMaterial( { color: Math.random() * 0xffffff } ) ); 
    return object;
}        
    
function init() {
    camera = new THREE.PerspectiveCamera( 27, window.innerWidth / window.innerHeight, 0.1, 35 );
    camera.position.z = 20;
    user.add( camera );
    
    scene = new THREE.Scene();
    scene.background = new THREE.Color( 0x2d4aa8 );

    
    
    renderer = new THREE.WebGLRenderer();
    
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    renderer.xr.enabled = true;

    controller1 = renderer.xr.getController( 0 );
    //log(controller1);
    controller1.addEventListener( 'selectstart', onSelectStart );
    controller1.addEventListener( 'selectend', onSelectEnd );
    controller1.addEventListener( 'connected', function ( event ) {
                    console.log("Controller 1 connected");
        console.log(event);
        realcont1 = event.data;
        realcont1connected = true;
    } );
    scene.add( controller1 );

    controller2 = renderer.xr.getController( 1 );
    scene.add( controller2 );
    
    controller2.addEventListener( 'selectstart', onSelectStartRight );
    controller2.addEventListener( 'selectend', onSelectEndRight );
    controller2.addEventListener( 'connected', function ( event ) {
                    console.log("Controller 2 connected");
        console.log(event);
        realcont2 = event.data;
        realcont2connected = true;
    } );

    document.body.appendChild( renderer.domElement );
    controls = new OrbitControls( camera, renderer.domElement );
    controls.autoRotate=false;
    controls.target.set( 0, 0, 0 );
    controls.update();
    

    document.body.appendChild( VRButton.createButton( renderer ) );
    var light = new THREE.AmbientLight( 0xffffff ); // soft white light
    scene.add( light );
    
    object1 = getHand();
    scene.add(object1);
    
    object2 = getHand();
    scene.add(object2); 
}
        

function handleController( object, controller ) {
    object.position.set(controller.position.x, controller.position.y, controller.position.z);
    object.position.add(user.position);
    object.rotation.set(controller.rotation.x, controller.rotation.y, controller.rotation.z);
    object.rotateX(-3.1415926/2);
}
        

function placePOI(location){
    // Place a point of interest in the given location
    var geometry = new THREE.CylinderGeometry( 0.1, 0.1, 0.6, 6 );
    var material = new THREE.MeshPhongMaterial({
      color: 0x00ff00,
      opacity: 0.5,
      transparent: true,
    });
    //var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
    var cube = new THREE.Mesh( geometry, material );
    
    var geometry2 = new THREE.CylinderGeometry( 0.1, 0.1, 2.0, 6 );
    var cube2 = new THREE.Mesh( geometry2, material );
    
    scene.add( cube );

    cube.position.x = location.x;
    cube.position.y = location.y;// Some offset for the hand rendering... 
    cube.position.z = location.z;

    POIs.push([cube, location]);
}

    
function animate() {
    renderer.setAnimationLoop( function () {
            controls.update(); // Very important otherwise you spend a few evenings debugging stuff... 

        
        // Change colors in whatever way I want...
//        if(colorBuffer){
//            for(var i=0; i < colorBuffer.count*3; i++){
//                colorBuffer.array[i] = 1.0;    
//            }
//            colorBuffer.needsUpdate = true;
//        }
//        
        
        
    if(realcont1connected){
        var gamepad = realcont1.gamepad;
        if(gamepad.buttons[4].pressed){
//            points.scale.x = 4.0
//            points.scale.y = 4.0
//            points.scale.z = 4.0
//            
//            for(var property in POIs){
//                property = POIs[property];
//                property[0].position.x = property[1].x*4.0;
//                property[0].position.y = property[1].y*4.0;
//                property[0].position.z = property[1].z*4.0;
//                
//                property[0].scale.x = 4.0
//                property[0].scale.y = 4.0
//                property[0].scale.z = 4.0
//            }
        }
        if(gamepad.buttons[5].pressed){
//            points.scale.x = 1.0
//            points.scale.y = 1.0
//            points.scale.z = 1.0
//            
//            for(var property in POIs){
//                property = POIs[property];
//                property[0].position.x = property[1].x*1.0;
//                property[0].position.y = property[1].y*1.0;
//                property[0].position.z = property[1].z*1.0;
//                
//                property[0].scale.x = 1.0
//                property[0].scale.y = 1.0
//                property[0].scale.z = 1.0
//            }
        }
        if (gamepad.buttons[1].pressed){
            if(!placePOIButtonPressed){
                placePOIButtonPressed = true;
                placePOI(object1.position); 
            }
        }
        else{
            placePOIButtonPressed = false;
        }
        for(var i=0; i < gamepad.buttons.length; i++){
            // A = 4
            // B = 5
            // grip = 1
            // center joystick = 3
            // Select = 0
//                if (gamepad.buttons[i].pressed){
//                    console.log(i);
//                }
        }
    }
        
    if(realcont2connected){
        var gamepad = realcont2.gamepad;
        
        
        if (gamepad.buttons[1].pressed){
            // This removes everything.... 
//             for(var property in POIs){
//                property = POIs[property];
//                scene.remove(property[0]);
//            }   
        }
        
    }

    // Draw the controllers
    

    if (selectionDirection != 0.0){
        let xrCamera = renderer.xr.getCamera(camera);
//        user.position.x += 20.0; 
        let e = xrCamera.matrixWorld.elements;
        let direction = new THREE.Vector3(selectionDirection*e[8], selectionDirection*e[9], selectionDirection*e[10]).normalize();
        direction.multiplyScalar(-0.05);
        user.position.add(direction);// HEY! Maybe this IS working after all!
        
//
//        points.position.add(direction);
//        
//        for(var property in POIs){
//            property = POIs[property];
//            property[0].position.add(direction);
//        }
    }
    handleController( object1, controller1 );
    handleController( object2, controller2 );
	renderer.render( scene, camera );

} );
}


  </script>
</body>

</html>
